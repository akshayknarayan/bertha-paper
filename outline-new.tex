% \notepanda{Proposal for beginning until ``We present a network stack''}
% \begin{outline}
% % \0 How applications communicate has changed in two significant ways in recent times.
% %     \1 First, applications now use a plethora of different communication APIs including UNIX sockets, io\_uring, XDP, DPDK, etc. to send and receive packets over the network.
% %     \1 Second, rather than directly sending and receiving bytes over the network, applications use libraries and services such as RPC libraries, PubSub services, etc. to meet application level goals.
% \0  However, these two changes in conjunction make it hard to change the specific communication API and library used by applications, since it requires extensive changes to the application.
%     \1 This is a problem because each of these choices offers a tradeoff in terms of application performance, resource efficiency and deployment requirements. \notepanda{We need to show this, but tbh we need to show this for reconfig in general}
%     \1 Where in the tradeoff curve one wants to be depends on where the application is deployed and how it is used.
% \0 In this paper we propose a new reconfigurable network stack that seeks to allow these choices to be changed dynamically.
% \end{outline}
% \notepanda{End scribble}

\begin{outline}
\0 How applications communicate has changed in two significant ways in recent times.
    \1 First, many applications require low-latency or high-throughput communication.
    \1 Second, almost all applications use communication primitive that are richer than stream or datagram delivery. Most networked applications use RPC libraries, and many rely on publish-subscribe and other communication primitives.
% \1 Demand from modern applications for sophisticated network features has driven a shift in the nature of network stacks to encompass more functionality.
%   \2 Where before the network stack's responsibility was limited to the transmission of bytes to the network interface card, the modern conception of the network stack has grown to encompass diverse features such as serialization, encryption, load balancing.
%     \3 Further, some applications' use of network functionality extends even beyond the NIC to include hosted services which implement communication primitives such as publish-subscribe or broadcast. (SQS, RabbitMQ, Kafka, etc) For example, these services are increasingly popular datapaths for communication between microservices, a popularly deployed application infrastructure pattern.
% \1 As applications demand more network features, network operators and service providers have responded with a diverse set of hardware and software.
%   \2 This includes both offloads and services.
%   \2 Application workloads have also changed.
\0 The network has changed in response to these requirements.
    \1 A plethora of networking APIs are now available including UNIX sockets, io\_uring, XDP, DPDK, etc., each offering different tradeoffs for performance, ease of use, and functionality.
    \1 Modern NICs and networks provide offloads that applications can use to implement rich functionality without paying performance penalties.
    \1 Several libraries, \eg GRPC and Thrift, are available that implement rich communication primitives.
    \1 Finally, many network providers now offer communication primitives such as publish-subscribe.
    % \1 First, applications now use a plethora of different communication APIs including UNIX sockets, io\_uring, XDP, DPDK, etc. to send and receive packets over the network.
    % \1 Second, rather than directly sending and receiving bytes over the network, applications use libraries and services such as RPC libraries, PubSub services, etc. to meet application level goals.
\0 Applications need to change to take advantage of these network improvements.
    \1 However, it is challenging for developers to decide which network libraries or features they should use, and when.
    \1 This is because each of these choices makes performance, management, and resource efficiency tradeoffs. \notePanda{Add examples.}
    \1 Which of these tradeoffs one wants depends on where the application is deployed, etc. But at present application developers to make these choices a-priori.
\0 In this paper we propose an alternate approach: a re-configurable and extensible network stack. 
% \1 Given this landscape, the network stack is faced with a choice. 
%   \2 Option 1: \emph{condense} its functionality into a small, traditional API (\eg packet transport) and leave application developers to manage the co-development and specialization of their apps to the networks they run in.
%   \2 Option 2: Embrace \emph{re-configurability} and \emph{expand} the network stack's responsibilities to include and coordinate the use of modern network features.
%   \2 In this paper, we argue that option 2 is the right way forward. We present a network stack, \name{}, that embraces re-configurability. 
 \1 By re-configurability, we mean that administrators should be able to chose between different implementations (which might make use of different offloads) at runtime without requiring changes to  application code.
 \1 By extensible, we meant that new network features and options can be incorporated into the network stack.
    % \3 In \name{}, the implementation of the features the application uses for its connections can change at runtime depending on runtime conditions including the availability of network services in the environment, the set of implementations connection peers support, and more.
\0 Why is re-configurability the right way forward? \notePanda{I don't think this paragraph should be here, but I don't understand plain old configurability hence did not change it.}
  \1 There are multiple approaches which offer ``plain old'' configurability (without the ``re-''). One of the most popular examples is DPDK~\cite{dpdk}, which offered an abstraction layer over underlying NIC hardware drivers, which made writing kernel-bypass network stacks significantly easier. Demikernel~\cite{demikernel} took this approach further with a library-OS approach supporting different datapaths.
    \2 Further up the stack, approaches such as Terraform~\cite{terraform} similarly seek to provide ``wrapper APIs'' over diverging underlying infrastructure functionality. 
  \1 These approaches are an encouraging first step towards coping with our challenge of diverse application network functionality. However, they do not attempt to address the challenge identified above: the app developer must specialize their application's network features to the datapath in question.
    \2 This means the application is not portable to other network runtime environments, or changes in the workload. This can be as bad as the application not running at all, but the application could also suffer worse performance.
    \2 Thus, the app developer needs to re-optimize applications (or, at least re-compile) when the application's environment changes. The application is no longer \emph{portable}.
\1 What are the challenges to adopting re-configuration?
  \2 We need agreement on app network features for all the peers in a connection; otherwise, semantic mismatches between connection participants would cause bugs. 
    \3 For example, if one peer uses ProtoBuf serialization but another is expecting Thrift, they would not be able to communicate. Since with re-configuration we allow this possibility, we need to ensure bugs like this one are prevented.
  \2 Therefore, to re-configure stacks at runtime, we need to reason about them at runtime. Currently, however, the network stack is a combination of explicit and implicit components (since traditional stacks end at the socket, or socket-analogue, boundary) and it is not possible to reason about these.
  \2 To reason about an app's network stack, we need a common representation of their component features. Since applications want to do a diverse set of things, this representation must be flexible and extensible.
\1 In \name{}, we address these challenges with an abstraction we call the \emph{Chunnel}. Chunnels are representations of a communication library's network functionality.
  \2 To achieve agreement on network stacks comprised of Chunnels, we implement \emph{negotiation}. Negotitation is the means by which apps that use chunnels can reach agreeement (when establishing a connection) on the implementations to use that are compatible with all the connection's participants.
\1 What are the limits of reconfiguration?\notePanda{See comments in \S3 for concerns around this.}
  \2 Some datapaths and libraries work by tightly integrating with the application runtime. For example, using the Shenango~\cite{shenango} network stack requires using the Shenango runtime's synchronization primitives; otherwise the runtime's thread scheduler becomes blocked and the application can easily deadlock.
  \2 Adopting these synchronization primitives to be runtime-reconfigurable across runtimes would involve both overhead and development pain. In these cases, lightweight wrappers to bridge the semantics between runtimes might be enough.
\1 This paper's contributions are:
  \2 \name{}, a network stack that (a) is extensible and supports extensions implementation various app network functionality beyond simple packet transport, and (b) is runtime-reconfigurable at various parts of the network stack.
  \2 The Chunnel abstraction, which enables \name{} to reason about implementation options for arbitrary network features.
  \2 A discussion and measurement of the costs and benefits of re-configurability.
\end{outline}
