\section{Motivation and Related Work}%
In this paper, we argue that it is necessary to change application-level network stacks to embrace communication libraries.
This is because of the following three changes that applications must tackle:

\paragrapha{The ``Narrow Waist'' has moved up.} While traditionally applications only required TCP/IP connections that they could establish using the socket API, this is no longer the case~\cite{http-narrow-waist}; modern applications need to adopt one of a variety of open-source libraries that implement more advanced communication abstractions that improve network security, simplify application management, and enable better logging and debugging. These libraries differ in their performance, features, and requirements, and thus, the ability to reconfigure which library is used can significantly reduce management and performance overheads for applications.
For example, applications have several options when choosing how to serialize data, each of which has different tradeoffs:
Apache Arrow is optimized for fast computation, Capnproto can reduce serialization overheads but requires the machine architecture to be identical between communicating hosts, and Protobufs are more general but sacrifice performance. The best choice varies by workload and deployment and thus requires assumptions beyond what the application developer might know.

\paragrapha{The emergence of deployment-specific offloads.} Most applications today run in virtualized environments (\eg cloud). These environments increasingly offer specialized services, including hardware offloads (\eg Google's offload-optimized PSP encryption or network sequencers such as Hydra~\cite{hydra}), and managed communication services (\eg publish-subscribe) that can improve application performance. To take advantage of this, applications must explicitly be designed to work in these environments. One approach to doing so is to limit where the application can run or to customize and maintain applications for each runtime environment, but these options decrease utility and increase cost. \name's reconfiguration can embrace environment-specific services without limiting an application's deployment or its network logic.

\paragrapha{Application performance, maintainability, and deployment cost \emph{all} matter.}
While applications now have stringent performance and efficiency requirements, application developers increasingly emphasize application maintenance burdens and deployment costs. 
Thus, it is impractical for common developers to produce bespoke application implementations for each possible runtime environment and workload combination. Even if the resulting (often significant~\cite{sqs-to-kafka}) development costs were acceptable, application workloads change dynamically, so a safe method to reconfigure application network stacks is necessary to adapt accordingly. Instead, as we show with \name, reconfiguring a single application implementation can navigate application performance-price tradeoffs without imposing developer burdens. 

\subsection{Related Work}\label{s:relwork}
Reconfigurability and extensibility have been extensively studied in the past. 
Overall, while prior approaches have focused only on the lower levels of the network stack (i.e., below the socket API), \name supports reconfiguration for all layers, including communication libraries. This presents new challenges in ensuring communication safety and compatibility.

\paragrapha{Reconfigurability in OSes} Prior approaches to program reconfiguration and extension rely on patching or replacing code in an executable system:  Ksplice~\cite{ksplice} and Proteos~\cite{proteos} developed approaches to patching kernel code to address security concerns, Nooks~\cite{nooks} and Shadow Drivers~\cite{shadow-drivers} describe approaches to replace drivers to avoid failures, and other systems~\cite{wfpatch, pylive} have provided tools for live-patching running applications. Another line of work, exemplified by VM-PHU~\cite{vm-phu} and NetKernel~\cite{netkernel} develops approaches to reconfigure executing VMs, but without considering communication libraries.

\paragrapha{Service Mesh} Service meshes~\cite{service-router, envoy, istio} implement communication functionality outside the applications, making it easier to reconfigure and change features such as how connections are encrypted or what data is logged. \name allows similar functionality, but unlike these, implements mechanisms to ensure that communicating endpoints have compatible configuration and to allow applications to vary configuration depending on what endpoint they are connected to.

\paragrapha{Reconfigurability in Traditional Network Stacks}
A lot of an application's communication functionality is split across the kernel and the user-space (\eg in communication libraries, service proxies, etc.), and its correctness can depend on agreement between endpoints (\eg agreement on serialization format). Therefore, work on reconfigurable network stacks has largely focused on individual pieces of functionality:
TAPS~\cite{taps} and the Fox project~\cite{biagioni} sought to modularize transport layer functionality.
The x-Kernel's Protocol Framework~\cite{xkernel} proposed an architecture for an extensible network stack, and Microprotocols~\cite{bhatti} built on this work with a proposal to extend the network stack with higher-level protocols such as atomic multicast.
Meanwhile, another early-stage workshop paper~\cite{bertha-hotnets} described a uniform abstraction for using offloads in the network stack but without reconfiguration.

\paragrapha{Hardware Portability} Since the early 1960s, many systems have aimed to provide \emph{portability}---rather than reconfigurability---thus allowing the system to work on a variety of hardware. Early examples include Unix V4, which was written in C to enable this. Recent examples include DPDK~\cite{dpdk} (which supports multiple NICs), Demikernel~\cite{demikernel} (which supports multiple network technologies including RDMA and kernel bypass networking), and Terraform~\cite{terraform} for configuring infrastructure across different cloud providers. These approaches allow the program to run on multiple deployments but do not specialize the program to these deployments and might thus carry a performance or efficiency overhead.
